/*
 * Copyright 2021 GFXFundamentals.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of GFXFundamentals. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function(root, factory) {  // eslint-disable-line
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], function() {
      return factory.call(root);
    });
  } else {
    // Browser globals
    root.webglUtils = factory.call(root);
  }
}(this, function() {
  'use strict';

  const topWindow = this;

  /** @module webgl-utils */

  function isInIFrame(w) {
    w = w || topWindow;
    return w !== w.top;
  }

  if (!isInIFrame()) {
    console.log("%c%s", 'color:blue;font-weight:bold;', 'for more about webgl-utils.js see:');  // eslint-disable-line
    console.log("%c%s", 'color:blue;font-weight:bold;', 'https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html');  // eslint-disable-line
  }

  /**
   * Wrapped logging function.
   * @param {string} msg The message to log.
   */
  function error(msg) {
    if (topWindow.console) {
      if (topWindow.console.error) {
        topWindow.console.error(msg);
      } else if (topWindow.console.log) {
        topWindow.console.log(msg);
      }
    }
  }


  /**
   * Error Callback
   * @callback ErrorCallback
   * @param {string} msg error message.
   * @memberOf module:webgl-utils
   */


  /**
   * Loads a shader.
   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
   * @param {string} shaderSource The shader source.
   * @param {number} shaderType The type of shader.
   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.
   * @return {WebGLShader} The created shader.
   */
  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {
    const errFn = opt_errorCallback || error;
    // Create the shader object
    const shader = gl.createShader(shaderType);

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status
    const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!compiled) {
      // Something went wrong during compilation; get the error
      const lastError = gl.getShaderInfoLog(shader);
      errFn('*** Error compiling shader \'' + shader + '\':' + lastError + `\n` + shaderSource.split('\n').map((l,i) => `${i + 1}: ${l}`).join('\n'));
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  /**
   * Creates a program, attaches shaders, binds attrib locations, links the
   * program and calls useProgram.
   * @param {WebGLShader[]} shaders The shaders to attach
   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
   *        on error. If you want something else pass an callback. It's passed an error message.
   * @memberOf module:webgl-utils
   */
  function createProgram(
      gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
    const errFn = opt_errorCallback || error;
    const program = gl.createProgram();
    shaders.forEach(function(shader) {
      gl.attachShader(program, shader);
    });
    if (opt_attribs) {
      opt_attribs.forEach(function(attrib, ndx) {
        gl.bindAttribLocation(
            program,
            opt_locations ? opt_locations[ndx] : ndx,
            attrib);
      });
    }
    gl.linkProgram(program);

    // Check the link status
    const linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
        // something went wrong with the link
        const lastError = gl.getProgramInfoLog(program);
        errFn('Error in program linking:' + lastError);

        gl.deleteProgram(program);
        return null;
    }
    return program;
  }

  /**
   * Loads a shader from a script tag.
   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
   * @param {string} scriptId The id of the script tag.
   * @param {number} opt_shaderType The type of shader. If not passed in it will
   *     be derived from the type of the script tag.
   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.
   * @return {WebGLShader} The created shader.
   */
  function createShaderFromScript(
      gl, scriptId, opt_shaderType, opt_errorCallback) {
    let shaderSource = '';
    let shaderType;
    const shaderScript = document.getElementById(scriptId);
    if (!shaderScript) {
      throw ('*** Error: unknown script element' + scriptId);
    }
    shaderSource = shaderScript.text;

    if (!opt_shaderType) {
      if (shaderScript.type === 'x-shader/x-vertex') {
        shaderType = gl.VERTEX_SHADER;
      } else if (shaderScript.type === 'x-shader/x-fragment') {
        shaderType = gl.FRAGMENT_SHADER;
      } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {
        throw ('*** Error: unknown shader type');
      }
    }

    return loadShader(
        gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,
        opt_errorCallback);
  }

  const defaultShaderType = [
    'VERTEX_SHADER',
    'FRAGMENT_SHADER',
  ];

  /**
   * Creates a program from 2 script tags.
   *
   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
   *        to use.
   * @param {string[]} shaderScriptIds Array of ids of the script
   *        tags for the shaders. The first is assumed to be the
   *        vertex shader, the second the fragment shader.
   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
   *        on error. If you want something else pass an callback. It's passed an error message.
   * @return {WebGLProgram} The created program.
   * @memberOf module:webgl-utils
   */
  function createProgramFromScripts(
      gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
    const shaders = [];
    for (let ii = 0; ii < shaderScriptIds.length; ++ii) {
      shaders.push(createShaderFromScript(
          gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback));
    }
    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);
  }

  /**
   * Creates a program from 2 sources.
   *
   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
   *        to use.
   * @param {string[]} shaderSourcess Array of sources for the
   *        shaders. The first is assumed to be the vertex shader,
   *        the second the fragment shader.
   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
   *        on error. If you want something else pass an callback. It's passed an error message.
   * @return {WebGLProgram} The created program.
   * @memberOf module:webgl-utils
   */
  function createProgramFromSources(
      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
    const shaders = [];
    for (let ii = 0; ii < shaderSources.length; ++ii) {
      shaders.push(loadShader(
          gl, shaderSources[ii], gl[defaultShaderType[ii]], opt_errorCallback));
    }
    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);
  }

  /**
   * Returns the corresponding bind point for a given sampler type
   */
  function getBindPointForSamplerType(gl, type) {
    if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;        // eslint-disable-line
    if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;  // eslint-disable-line
    return undefined;
  }

  /**
   * @typedef {Object.<string, function>} Setters
   */

  /**
   * Creates setter functions for all uniforms of a shader
   * program.
   *
   * @see {@link module:webgl-utils.setUniforms}
   *
   * @param {WebGLProgram} program the program to create setters for.
   * @returns {Object.<string, function>} an object with a setter by name for each uniform
   * @memberOf module:webgl-utils
   */
  function createUniformSetters(gl, program) {
    let textureUnit = 0;

    /**
     * Creates a setter for a uniform of the given program with it's
     * location embedded in the setter.
     * @param {WebGLProgram} program
     * @param {WebGLUniformInfo} uniformInfo
     * @returns {function} the created setter.
     */
    function createUniformSetter(program, uniformInfo) {
      const location = gl.getUniformLocation(program, uniformInfo.name);
      const type = uniformInfo.type;
      // Check if this uniform is an array
      const isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === '[0]');
      if (type === gl.FLOAT && isArray) {
        return function(v) {
          gl.uniform1fv(location, v);
        };
      }
      if (type === gl.FLOAT) {
        return function(v) {
          gl.uniform1f(location, v);
        };
      }
      if (type === gl.FLOAT_VEC2) {
        return function(v) {
          gl.uniform2fv(location, v);
        };
      }
      if (type === gl.FLOAT_VEC3) {
        return function(v) {
          gl.uniform3fv(location, v);
        };
      }
      if (type === gl.FLOAT_VEC4) {
        return function(v) {
          gl.uniform4fv(location, v);
        };
      }
      if (type === gl.INT && isArray) {
        return function(v) {
          gl.uniform1iv(location, v);
        };
      }
      if (type === gl.INT) {
        return function(v) {
          gl.uniform1i(location, v);
        };
      }
      if (type === gl.INT_VEC2) {
        return function(v) {
          gl.uniform2iv(location, v);
        };
      }
      if (type === gl.INT_VEC3) {
        return function(v) {
          gl.uniform3iv(location, v);
        };
      }
      if (type === gl.INT_VEC4) {
        return function(v) {
          gl.uniform4iv(location, v);
        };
      }
      if (type === gl.BOOL) {
        return function(v) {
          gl.uniform1iv(location, v);
        };
      }
      if (type === gl.BOOL_VEC2) {
        return function(v) {
          gl.uniform2iv(location, v);
        };
      }
      if (type === gl.BOOL_VEC3) {
        return function(v) {
          gl.uniform3iv(location, v);
        };
      }
      if (type === gl.BOOL_VEC4) {
        return function(v) {
          gl.uniform4iv(location, v);
        };
      }
      if (type === gl.FLOAT_MAT2) {
        return function(v) {
          gl.uniformMatrix2fv(location, false, v);
        };
      }
      if (type === gl.FLOAT_MAT3) {
        return function(v) {
          gl.uniformMatrix3fv(location, false, v);
        };
      }
      if (type === gl.FLOAT_MAT4) {
        return function(v) {
          gl.uniformMatrix4fv(location, false, v);
        };
      }
      if ((type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) && isArray) {
        const units = [];
        for (let ii = 0; ii < info.size; ++ii) {
          units.push(textureUnit++);
        }
        return function(bindPoint, units) {
          return function(textures) {
            gl.uniform1iv(location, units);
            textures.forEach(function(texture, index) {
              gl.activeTexture(gl.TEXTURE0 + units[index]);
              gl.bindTexture(bindPoint, texture);
            });
          };
        }(getBindPointForSamplerType(gl, type), units);
      }
      if (type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) {
        return function(bindPoint, unit) {
          return function(texture) {
            gl.uniform1i(location, unit);
            gl.activeTexture(gl.TEXTURE0 + unit);
            gl.bindTexture(bindPoint, texture);
          };
        }(getBindPointForSamplerType(gl, type), textureUnit++);
      }
      throw ('unknown type: 0x' + type.toString(16)); // we should never get here.
    }

    const uniformSetters = { };
    const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (let ii = 0; ii < numUniforms; ++ii) {
      const uniformInfo = gl.getActiveUniform(program, ii);
      if (!uniformInfo) {
        break;
      }
      let name = uniformInfo.name;
      // remove the array suffix.
      if (name.substr(-3) === '[0]') {
        name = name.substr(0, name.length - 3);
      }
      const setter = createUniformSetter(program, uniformInfo);
      uniformSetters[name] = setter;
    }
    return uniformSetters;
  }

  /**
   * Set uniforms and binds related textures.
   *
   * Example:
   *
   *     let programInfo = createProgramInfo(
   *         gl, ["some-vs", "some-fs"]);
   *
   *     let tex1 = gl.createTexture();
   *     let tex2 = gl.createTexture();
   *
   *     ... assume we setup the textures with data ...
   *
   *     let uniforms = {
   *       u_someSampler: tex1,
   *       u_someOtherSampler: tex2,
   *       u_someColor: [1,0,0,1],
   *       u_somePosition: [0,1,1],
   *       u_someMatrix: [
   *         1,0,0,0,
   *         0,1,0,0,
   *         0,0,1,0,
   *         0,0,0,0,
   *       ],
   *     };
   *
   *     gl.useProgram(program);
   *
   * This will automatically bind the textures AND set the
   * uniforms.
   *
   *     setUniforms(programInfo.uniformSetters, uniforms);
   *
   * For the example above it is equivalent to
   *
   *     let texUnit = 0;
   *     gl.activeTexture(gl.TEXTURE0 + texUnit);
   *     gl.bindTexture(gl.TEXTURE_2D, tex1);
   *     gl.uniform1i(u_someSamplerLocation, texUnit++);
   *     gl.activeTexture(gl.TEXTURE0 + texUnit);
   *     gl.bindTexture(gl.TEXTURE_2D, tex2);
   *     gl.uniform1i(u_someSamplerLocation, texUnit++);
   *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);
   *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);
   *     gl.uniformMatrix4fv(u_someMatrix, false, [
   *         1,0,0,0,
   *         0,1,0,0,
   *         0,0,1,0,
   *         0,0,0,0,
   *       ]);
   *
   * Note it is perfectly reasonable to call `setUniforms` multiple times. For example
   *
   *     let uniforms = {
   *       u_someSampler: tex1,
   *       u_someOtherSampler: tex2,
   *     };
   *
   *     let moreUniforms {
   *       u_someColor: [1,0,0,1],
   *       u_somePosition: [0,1,1],
   *       u_someMatrix: [
   *         1,0,0,0,
   *         0,1,0,0,
   *         0,0,1,0,
   *         0,0,0,0,
   *       ],
   *     };
   *
   *     setUniforms(programInfo.uniformSetters, uniforms);
   *     setUniforms(programInfo.uniformSetters, moreUniforms);
   *
   * @param {Object.<string, function>|module:webgl-utils.ProgramInfo} setters the setters returned from
   *        `createUniformSetters` or a ProgramInfo from {@link module:webgl-utils.createProgramInfo}.
   * @param {Object.<string, value>} an object with values for the
   *        uniforms.
   * @memberOf module:webgl-utils
   */
  function setUniforms(setters, ...values) {
    setters = setters.uniformSetters || setters;
    for (const uniforms of values) {
      Object.keys(uniforms).forEach(function(name) {
        const setter = setters[name];
        if (setter) {
          setter(uniforms[name]);
        }
      });
    }
  }

  /**
   * Creates setter functions for all attributes of a shader
   * program. You can pass this to {@link module:webgl-utils.setBuffersAndAttributes} to set all your buffers and attributes.
   *
   * @see {@link module:webgl-utils.setAttributes} for example
   * @param {WebGLProgram} program the program to create setters for.
   * @return {Object.<string, function>} an object with a setter for each attribute by name.
   * @memberOf module:webgl-utils
   */
  function createAttributeSetters(gl, program) {
    const attribSetters = {
    };

    function createAttribSetter(index) {
      return function(b) {
          if (b.value) {
            gl.disableVertexAttribArray(index);
            switch (b.value.length) {
              case 4:
                gl.vertexAttrib4fv(index, b.value);
                break;
              case 3:
                gl.vertexAttrib3fv(index, b.value);
                break;
              case 2:
                gl.vertexAttrib2fv(index, b.value);
                break;
              case 1:
                gl.vertexAttrib1fv(index, b.value);
                break;
              default:
                throw new Error('the length of a float constant value must be between 1 and 4!');
            }
          } else {
            gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
            gl.enableVertexAttribArray(index);
            gl.vertexAttribPointer(
                index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);
          }
        };
    }

    const numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let ii = 0; ii < numAttribs; ++ii) {
      const attribInfo = gl.getActiveAttrib(program, ii);
      if (!attribInfo) {
        break;
      }
      const index = gl.getAttribLocation(program, attribInfo.name);
      attribSetters[attribInfo.name] = createAttribSetter(index);
    }

    return attribSetters;
  }

  /**
   * Sets attributes and binds buffers (deprecated... use {@link module:webgl-utils.setBuffersAndAttributes})
   *
   * Example:
   *
   *     let program = createProgramFromScripts(
   *         gl, ["some-vs", "some-fs"]);
   *
   *     let attribSetters = createAttributeSetters(program);
   *
   *     let positionBuffer = gl.createBuffer();
   *     let texcoordBuffer = gl.createBuffer();
   *
   *     let attribs = {
   *       a_position: {buffer: positionBuffer, numComponents: 3},
   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
   *     };
   *
   *     gl.useProgram(program);
   *
   * This will automatically bind the buffers AND set the
   * attributes.
   *
   *     setAttributes(attribSetters, attribs);
   *
   * Properties of attribs. For each attrib you can add
   * properties:
   *
   * *   type: the type of data in the buffer. Default = gl.FLOAT
   * *   normalize: whether or not to normalize the data. Default = false
   * *   stride: the stride. Default = 0
   * *   offset: offset into the buffer. Default = 0
   *
   * For example if you had 3 value float positions, 2 value
   * float texcoord and 4 value uint8 colors you'd setup your
   * attribs like this
   *
   *     let attribs = {
   *       a_position: {buffer: positionBuffer, numComponents: 3},
   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
   *       a_color: {
   *         buffer: colorBuffer,
   *         numComponents: 4,
   *         type: gl.UNSIGNED_BYTE,
   *         normalize: true,
   *       },
   *     };
   *
   * @param {Object.<string, function>|model:webgl-utils.ProgramInfo} setters Attribute setters as returned from createAttributeSetters or a ProgramInfo as returned {@link module:webgl-utils.createProgramInfo}
   * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.
   * @memberOf module:webgl-utils
   * @deprecated use {@link module:webgl-utils.setBuffersAndAttributes}
   */
  function setAttributes(setters, attribs) {
    setters = setters.attribSetters || setters;
    Object.keys(attribs).forEach(function(name) {
      const setter = setters[name];
      if (setter) {
        setter(attribs[name]);
      }
    });
  }

  /**
   * Creates a vertex array object and then sets the attributes
   * on it
   *
   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
   *        to use.
   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
   * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.
   * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
   */
  function createVAOAndSetAttributes(gl, setters, attribs, indices) {
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    setAttributes(setters, attribs);
    if (indices) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);
    }
    // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER
    // like when creating buffers for other stuff will mess up this VAO's binding
    gl.bindVertexArray(null);
    return vao;
  }

  /**
   * Creates a vertex array object and then sets the attributes
   * on it
   *
   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
   *        to use.
   * @param {Object.<string, function>| module:webgl-utils.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters
   * @param {module:webgl-utils:BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
   * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
   */
  function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {
    return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);
  }

  /**
   * @typedef {Object} ProgramInfo
   * @property {WebGLProgram} program A shader program
   * @property {Object<string, function>} uniformSetters: object of setters as returned from createUniformSetters,
   * @property {Object<string, function>} attribSetters: object of setters as returned from createAttribSetters,
   * @memberOf module:webgl-utils
   */

  /**
   * Creates a ProgramInfo from 2 sources.
   *
   * A ProgramInfo contains
   *
   *     programInfo = {
   *        program: WebGLProgram,
   *        uniformSetters: object of setters as returned from createUniformSetters,
   *        attribSetters: object of setters as returned from createAttribSetters,
   *     }
   *
   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
   *        to use.
   * @param {string[]} shaderSourcess Array of sources for the
   *        shaders or ids. The first is assumed to be the vertex shader,
   *        the second the fragment shader.
   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
   *        on error. If you want something else pass an callback. It's passed an error message.
   * @return {module:webgl-utils.ProgramInfo} The created program.
   * @memberOf module:webgl-utils
   */
  function createProgramInfo(
      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
    shaderSources = shaderSources.map(function(source) {
      const script = document.getElementById(source);
      return script ? script.text : source;
    });
    const program = webglUtils.createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);
    if (!program) {
      return null;
    }
    const uniformSetters = createUniformSetters(gl, program);
    const attribSetters = createAttributeSetters(gl, program);
    return {
      program: program,
      uniformSetters: uniformSetters,
      attribSetters: attribSetters,
    };
  }

  /**
   * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate
   *
   * Example:
   *
   *     let programInfo = createProgramInfo(
   *         gl, ["some-vs", "some-fs"]);
   *
   *     let arrays = {
   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
   *     };
   *
   *     let bufferInfo = createBufferInfoFromArrays(gl, arrays);
   *
   *     gl.useProgram(programInfo.program);
   *
   * This will automatically bind the buffers AND set the
   * attributes.
   *
   *     setBuffersAndAttributes(programInfo.attribSetters, bufferInfo);
   *
   * For the example above it is equivilent to
   *
   *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
   *     gl.enableVertexAttribArray(a_positionLocation);
   *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);
   *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
   *     gl.enableVertexAttribArray(a_texcoordLocation);
   *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);
   *
   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
   * @param {Object.<string, function>} setters Attribute setters as returned from `createAttributeSetters`
   * @param {module:webgl-utils.BufferInfo} buffers a BufferInfo as returned from `createBufferInfoFromArrays`.
   * @memberOf module:webgl-utils
   */
  function setBuffersAndAttributes(gl, setters, buffers) {
    setAttributes(setters, buffers.attribs);
    if (buffers.indices) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
    }
  }

  // Add your prefix here.
  const browserPrefixes = [
    '',
    'MOZ_',
    'OP_',
    'WEBKIT_',
  ];

  /**
   * Given an extension name like WEBGL_compressed_texture_s3tc
   * returns the supported version extension, like
   * WEBKIT_WEBGL_compressed_teture_s3tc
   * @param {string} name Name of extension to look for
   * @return {WebGLExtension} The extension or undefined if not
   *     found.
   * @memberOf module:webgl-utils
   */
  function getExtensionWithKnownPrefixes(gl, name) {
    for (let ii = 0; ii < browserPrefixes.length; ++ii) {
      const prefixedName = browserPrefixes[ii] + name;
      const ext = gl.getExtension(prefixedName);
      if (ext) {
        return ext;
      }
    }
    return undefined;
  }

  /**
   * Resize a canvas to match the size its displayed.
   * @param {HTMLCanvasElement} canvas The canvas to resize.
   * @param {number} [multiplier] amount to multiply by.
   *    Pass in window.devicePixelRatio for native pixels.
   * @return {boolean} true if the canvas was resized.
   * @memberOf module:webgl-utils
   */
  function resizeCanvasToDisplaySize(canvas, multiplier) {
    multiplier = multiplier || 1;
    const width  = canvas.clientWidth  * multiplier | 0;
    const height = canvas.clientHeight * multiplier | 0;
    if (canvas.width !== width ||  canvas.height !== height) {
      canvas.width  = width;
      canvas.height = height;
      return true;
    }
    return false;
  }

  // Add `push` to a typed array. It just keeps a 'cursor'
  // and allows use to `push` values into the array so we
  // don't have to manually compute offsets
  function augmentTypedArray(typedArray, numComponents) {
    let cursor = 0;
    typedArray.push = function() {
      for (let ii = 0; ii < arguments.length; ++ii) {
        const value = arguments[ii];
        if (value instanceof Array || (value.buffer && value.buffer instanceof ArrayBuffer)) {
          for (let jj = 0; jj < value.length; ++jj) {
            typedArray[cursor++] = value[jj];
          }
        } else {
          typedArray[cursor++] = value;
        }
      }
    };
    typedArray.reset = function(opt_index) {
      cursor = opt_index || 0;
    };
    typedArray.numComponents = numComponents;
    Object.defineProperty(typedArray, 'numElements', {
      get: function() {
        return this.length / this.numComponents | 0;
      },
    });
    return typedArray;
  }

  /**
   * creates a typed array with a `push` function attached
   * so that you can easily *push* values.
   *
   * `push` can take multiple arguments. If an argument is an array each element
   * of the array will be added to the typed array.
   *
   * Example:
   *
   *     let array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values
   *     array.push(1, 2, 3);
   *     array.push([4, 5, 6]);
   *     // array now contains [1, 2, 3, 4, 5, 6]
   *
   * Also has `numComponents` and `numElements` properties.
   *
   * @param {number} numComponents number of components
   * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.
   * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.
   * @return {ArrayBuffer} A typed array.
   * @memberOf module:webgl-utils
   */
  function createAugmentedTypedArray(numComponents, numElements, opt_type) {
    const Type = opt_type || Float32Array;
    return augmentTypedArray(new Type(numComponents * numElements), numComponents);
  }

  function createBufferFromTypedArray(gl, array, type, drawType) {
    type = type || gl.ARRAY_BUFFER;
    const buffer = gl.createBuffer();
    gl.bindBuffer(type, buffer);
    gl.bufferData(type, array, drawType || gl.STATIC_DRAW);
    return buffer;
  }

  function allButIndices(name) {
    return name !== 'indices';
  }

  function createMapping(obj) {
    const mapping = {};
    Object.keys(obj).filter(allButIndices).forEach(function(key) {
      mapping['a_' + key] = key;
    });
    return mapping;
  }

  function getGLTypeForTypedArray(gl, typedArray) {
    if (typedArray instanceof Int8Array)    { return gl.BYTE; }            // eslint-disable-line
    if (typedArray instanceof Uint8Array)   { return gl.UNSIGNED_BYTE; }   // eslint-disable-line
    if (typedArray instanceof Int16Array)   { return gl.SHORT; }           // eslint-disable-line
    if (typedArray instanceof Uint16Array)  { return gl.UNSIGNED_SHORT; }  // eslint-disable-line
    if (typedArray instanceof Int32Array)   { return gl.INT; }             // eslint-disable-line
    if (typedArray instanceof Uint32Array)  { return gl.UNSIGNED_INT; }    // eslint-disable-line
    if (typedArray instanceof Float32Array) { return gl.FLOAT; }           // eslint-disable-line
    throw 'unsupported typed array type';
  }

  // This is really just a guess. Though I can't really imagine using
  // anything else? Maybe for some compression?
  function getNormalizationForTypedArray(typedArray) {
    if (typedArray instanceof Int8Array)    { return true; }  // eslint-disable-line
    if (typedArray instanceof Uint8Array)   { return true; }  // eslint-disable-line
    return false;
  }

  function isArrayBuffer(a) {
    return a.buffer && a.buffer instanceof ArrayBuffer;
  }

  function guessNumComponentsFromName(name, length) {
    let numComponents;
    if (name.indexOf('coord') >= 0) {
      numComponents = 2;
    } else if (name.indexOf('color') >= 0) {
      numComponents = 4;
    } else {
      numComponents = 3;  // position, normals, indices ...
    }

    if (length % numComponents > 0) {
      throw 'can not guess numComponents. You should specify it.';
    }

    return numComponents;
  }

  function makeTypedArray(array, name) {
    if (isArrayBuffer(array)) {
      return array;
    }

    if (array.data && isArrayBuffer(array.data)) {
      return array.data;
    }

    if (Array.isArray(array)) {
      array = {
        data: array,
      };
    }

    if (!array.numComponents) {
      array.numComponents = guessNumComponentsFromName(name, array.length);
    }

    let type = array.type;
    if (!type) {
      if (name === 'indices') {
        type = Uint16Array;
      }
    }
    const typedArray = createAugmentedTypedArray(array.numComponents, array.data.length / array.numComponents | 0, type);
    typedArray.push(array.data);
    return typedArray;
  }

  /**
   * @typedef {Object} AttribInfo
   * @property {number} [numComponents] the number of components for this attribute.
   * @property {number} [size] the number of components for this attribute.
   * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`
   * @property {boolean} [normalized] whether or not to normalize the data. Default = false
   * @property {number} [offset] offset into buffer in bytes. Default = 0
   * @property {number} [stride] the stride in bytes per element. Default = 0
   * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute
   * @memberOf module:webgl-utils
   */


  /**
   * Creates a set of attribute data and WebGLBuffers from set of arrays
   *
   * Given
   *
   *      let arrays = {
   *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
   *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
   *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
   *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },
   *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
   *      };
   *
   * returns something like
   *
   *      let attribs = {
   *        a_position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
   *        a_texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
   *        a_normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
   *        a_color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },
   *      };
   *
   * @param {WebGLRenderingContext} gl The webgl rendering context.
   * @param {Object.<string, array|typedarray>} arrays The arrays
   * @param {Object.<string, string>} [opt_mapping] mapping from attribute name to array name.
   *     if not specified defaults to "a_name" -> "name".
   * @return {Object.<string, module:webgl-utils.AttribInfo>} the attribs
   * @memberOf module:webgl-utils
   */
  function createAttribsFromArrays(gl, arrays, opt_mapping) {
    const mapping = opt_mapping || createMapping(arrays);
    const attribs = {};
    Object.keys(mapping).forEach(function(attribName) {
      const bufferName = mapping[attribName];
      const origArray = arrays[bufferName];
      if (origArray.value) {
        attribs[attribName] = {
          value: origArray.value,
        };
      } else {
        const array = makeTypedArray(origArray, bufferName);
        attribs[attribName] = {
          buffer:        createBufferFromTypedArray(gl, array),
          numComponents: origArray.numComponents || array.numComponents || guessNumComponentsFromName(bufferName),
          type:          getGLTypeForTypedArray(gl, array),
          normalize:     getNormalizationForTypedArray(array),
        };
      }
    });
    return attribs;
  }

  function getArray(array) {
    return array.length ? array : array.data;
  }

  const texcoordRE = /coord|texture/i;
  const colorRE = /color|colour/i;

  function guessNumComponentsFromName(name, length) {
    let numComponents;
    if (texcoordRE.test(name)) {
      numComponents = 2;
    } else if (colorRE.test(name)) {
      numComponents = 4;
    } else {
      numComponents = 3;  // position, normals, indices ...
    }

    if (length % numComponents > 0) {
      throw new Error(`Can not guess numComponents for attribute '${name}'. Tried ${numComponents} but ${length} values is not evenly divisible by ${numComponents}. You should specify it.`);
    }

    return numComponents;
  }

  function getNumComponents(array, arrayName) {
    return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);
  }

  /**
   * tries to get the number of elements from a set of arrays.
   */
  const positionKeys = ['position', 'positions', 'a_position'];
  function getNumElementsFromNonIndexedArrays(arrays) {
    let key;
    for (const k of positionKeys) {
      if (k in arrays) {
        key = k;
        break;
      }
    }
    key = key || Object.keys(arrays)[0];
    const array = arrays[key];
    const length = getArray(array).length;
    const numComponents = getNumComponents(array, key);
    const numElements = length / numComponents;
    if (length % numComponents > 0) {
      throw new Error(`numComponents ${numComponents} not correct for length ${length}`);
    }
    return numElements;
  }

  /**
   * @typedef {Object} BufferInfo
   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
   * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.
   * @property {Object.<string, module:webgl-utils.AttribInfo>} attribs The attribs approriate to call `setAttributes`
   * @memberOf module:webgl-utils
   */


  /**
   * Creates a BufferInfo from an object of arrays.
   *
   * This can be passed to {@link module:webgl-utils.setBuffersAndAttributes} and to
   * {@link module:webgl-utils:drawBufferInfo}.
   *
   * Given an object like
   *
   *     let arrays = {
   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
   *     };
   *
   *  Creates an BufferInfo like this
   *
   *     bufferInfo = {
   *       numElements: 4,        // or whatever the number of elements is
   *       indices: WebGLBuffer,  // this property will not exist if there are no indices
   *       attribs: {
   *         a_position: { buffer: WebGLBuffer, numComponents: 3, },
   *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },
   *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },
   *       },
   *     };
   *
   *  The properties of arrays can be JavaScript arrays in which case the number of components
   *  will be guessed.
   *
   *     let arrays = {
   *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],
   *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],
   *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
   *        indices:  [0, 1, 2, 1, 2, 3],
   *     };
   *
   *  They can also by TypedArrays
   *
   *     let arrays = {
   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
   *     };
   *
   *  Or augmentedTypedArrays
   *
   *     let positions = createAugmentedTypedArray(3, 4);
   *     let texcoords = createAugmentedTypedArray(2, 4);
   *     let normals   = createAugmentedTypedArray(3, 4);
   *     let indices   = createAugmentedTypedArray(3, 2, Uint16Array);
   *
   *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);
   *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);
   *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
   *     indices.push([0, 1, 2, 1, 2, 3]);
   *
   *     let arrays = {
   *        position: positions,
   *        texcoord: texcoords,
   *        normal:   normals,
   *        indices:  indices,
   *     };
   *
   * For the last example it is equivalent to
   *
   *     let bufferInfo = {
   *       attribs: {
   *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },
   *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },
   *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },
   *       },
   *       indices: gl.createBuffer(),
   *       numElements: 6,
   *     };
   *
   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);
   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);
   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);
   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);
   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);
   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);
   *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);
   *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);
   *
   * @param {WebGLRenderingContext} gl A WebGLRenderingContext
   * @param {Object.<string, array|object|typedarray>} arrays Your data
   * @param {Object.<string, string>} [opt_mapping] an optional mapping of attribute to array name.
   *    If not passed in it's assumed the array names will be mapped to an attribute
   *    of the same name with "a_" prefixed to it. An other words.
   *
   *        let arrays = {
   *           position: ...,
   *           texcoord: ...,
   *           normal:   ...,
   *           indices:  ...,
   *        };
   *
   *        bufferInfo = createBufferInfoFromArrays(gl, arrays);
   *
   *    Is the same as
   *
   *        let arrays = {
   *           position: ...,
   *           texcoord: ...,
   *           normal:   ...,
   *           indices:  ...,
   *        };
   *
   *        let mapping = {
   *          a_position: "position",
   *          a_texcoord: "texcoord",
   *          a_normal:   "normal",
   *        };
   *
   *        bufferInfo = createBufferInfoFromArrays(gl, arrays, mapping);
   *
   * @return {module:webgl-utils.BufferInfo} A BufferInfo
   * @memberOf module:webgl-utils
   */
  function createBufferInfoFromArrays(gl, arrays, opt_mapping) {
    const bufferInfo = {
      attribs: createAttribsFromArrays(gl, arrays, opt_mapping),
    };
    let indices = arrays.indices;
    if (indices) {
      indices = makeTypedArray(indices, 'indices');
      bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);
      bufferInfo.numElements = indices.length;
    } else {
      bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);
    }

    return bufferInfo;
  }

  /**
   * Creates buffers from typed arrays
   *
   * Given something like this
   *
   *     let arrays = {
   *        positions: [1, 2, 3],
   *        normals: [0, 0, 1],
   *     }
   *
   * returns something like
   *
   *     buffers = {
   *       positions: WebGLBuffer,
   *       normals: WebGLBuffer,
   *     }
   *
   * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.
   *
   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
   * @param {Object<string, array|typedarray>} arrays
   * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array
   * @memberOf module:webgl-utils
   */
  function createBuffersFromArrays(gl, arrays) {
    const buffers = { };
    Object.keys(arrays).forEach(function(key) {
      const type = key === 'indices' ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
      const array = makeTypedArray(arrays[key], name);
      buffers[key] = createBufferFromTypedArray(gl, array, type);
    });

    // hrm
    if (arrays.indices) {
      buffers.numElements = arrays.indices.length;
    } else if (arrays.position) {
      buffers.numElements = arrays.position.length / 3;
    }

    return buffers;
  }

  /**
   * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate
   *
   * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself
   * but calling this means if you switch from indexed data to non-indexed
   * data you don't have to remember to update your draw call.
   *
   * @param {WebGLRenderingContext} gl A WebGLRenderingContext
   * @param {module:webgl-utils.BufferInfo} bufferInfo as returned from createBufferInfoFromArrays
   * @param {enum} [primitiveType] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...)
   * @param {number} [count] An optional count. Defaults to bufferInfo.numElements
   * @param {number} [offset] An optional offset. Defaults to 0.
   * @memberOf module:webgl-utils
   */
  function drawBufferInfo(gl, bufferInfo, primitiveType, count, offset) {
    const indices = bufferInfo.indices;
    primitiveType = primitiveType === undefined ? gl.TRIANGLES : primitiveType;
    const numElements = count === undefined ? bufferInfo.numElements : count;
    offset = offset === undefined ? 0 : offset;
    if (indices) {
      gl.drawElements(primitiveType, numElements, gl.UNSIGNED_SHORT, offset);
    } else {
      gl.drawArrays(primitiveType, offset, numElements);
    }
  }

  /**
   * @typedef {Object} DrawObject
   * @property {module:webgl-utils.ProgramInfo} programInfo A ProgramInfo as returned from createProgramInfo
   * @property {module:webgl-utils.BufferInfo} bufferInfo A BufferInfo as returned from createBufferInfoFromArrays
   * @property {Object<string, ?>} uniforms The values for the uniforms
   * @memberOf module:webgl-utils
   */

  /**
   * Draws a list of objects
   * @param {WebGLRenderingContext} gl A WebGLRenderingContext
   * @param {DrawObject[]} objectsToDraw an array of objects to draw.
   * @memberOf module:webgl-utils
   */
  function drawObjectList(gl, objectsToDraw) {
    let lastUsedProgramInfo = null;
    let lastUsedBufferInfo = null;

    objectsToDraw.forEach(function(object) {
      const programInfo = object.programInfo;
      const bufferInfo = object.bufferInfo;
      let bindBuffers = false;

      if (programInfo !== lastUsedProgramInfo) {
        lastUsedProgramInfo = programInfo;
        gl.useProgram(programInfo.program);
        bindBuffers = true;
      }

      // Setup all the needed attributes.
      if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
        lastUsedBufferInfo = bufferInfo;
        setBuffersAndAttributes(gl, programInfo.attribSetters, bufferInfo);
      }

      // Set the uniforms.
      setUniforms(programInfo.uniformSetters, object.uniforms);

      // Draw
      drawBufferInfo(gl, bufferInfo);
    });
  }

  function glEnumToString(gl, v) {
    const results = [];
    for (const key in gl) {
      if (gl[key] === v) {
        results.push(key);
      }
    }
    return results.length
        ? results.join(' | ')
        : `0x${v.toString(16)}`;
  }

  const isIE = /*@cc_on!@*/false || !!document.documentMode;
  // Edge 20+
  const isEdge = !isIE && !!window.StyleMedia;
  if (isEdge) {
    // Hack for Edge. Edge's WebGL implmentation is crap still and so they
    // only respond to "experimental-webgl". I don't want to clutter the
    // examples with that so his hack works around it
    HTMLCanvasElement.prototype.getContext = function(origFn) {
      return function() {
        let args = arguments;
        const type = args[0];
        if (type === 'webgl') {
          args = [].slice.call(arguments);
          args[0] = 'experimental-webgl';
        }
        return origFn.apply(this, args);
      };
    }(HTMLCanvasElement.prototype.getContext);
  }

  return {
    createAugmentedTypedArray: createAugmentedTypedArray,
    createAttribsFromArrays: createAttribsFromArrays,
    createBuffersFromArrays: createBuffersFromArrays,
    createBufferInfoFromArrays: createBufferInfoFromArrays,
    createAttributeSetters: createAttributeSetters,
    createProgram: createProgram,
    createProgramFromScripts: createProgramFromScripts,
    createProgramFromSources: createProgramFromSources,
    createProgramInfo: createProgramInfo,
    createUniformSetters: createUniformSetters,
    createVAOAndSetAttributes: createVAOAndSetAttributes,
    createVAOFromBufferInfo: createVAOFromBufferInfo,
    drawBufferInfo: drawBufferInfo,
    drawObjectList: drawObjectList,
    glEnumToString: glEnumToString,
    getExtensionWithKnownPrefixes: getExtensionWithKnownPrefixes,
    resizeCanvasToDisplaySize: resizeCanvasToDisplaySize,
    setAttributes: setAttributes,
    setBuffersAndAttributes: setBuffersAndAttributes,
    setUniforms: setUniforms,
  };

}));

;
/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */

(function(global){
  var module = global.noise = {};

  function Grad(x, y, z) {
    this.x = x; this.y = y; this.z = z;
  }

  Grad.prototype.dot2 = function(x, y) {
    return this.x*x + this.y*y;
  };

  Grad.prototype.dot3 = function(x, y, z) {
    return this.x*x + this.y*y + this.z*z;
  };

  var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
               new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
               new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];

  var p = [151,160,137,91,90,15,
  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
  // To remove the need for index wrapping, double the permutation table length
  var perm = new Array(512);
  var gradP = new Array(512);

  // This isn't a very good seeding function, but it works ok. It supports 2^16
  // different seed values. Write something better if you need more seeds.
  module.seed = function(seed) {
    if(seed > 0 && seed < 1) {
      // Scale the seed out
      seed *= 65536;
    }

    seed = Math.floor(seed);
    if(seed < 256) {
      seed |= seed << 8;
    }

    for(var i = 0; i < 256; i++) {
      var v;
      if (i & 1) {
        v = p[i] ^ (seed & 255);
      } else {
        v = p[i] ^ ((seed>>8) & 255);
      }

      perm[i] = perm[i + 256] = v;
      gradP[i] = gradP[i + 256] = grad3[v % 12];
    }
  };

  module.seed(0);

  /*
  for(var i=0; i<256; i++) {
    perm[i] = perm[i + 256] = p[i];
    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
  }*/

  // Skewing and unskewing factors for 2, 3, and 4 dimensions
  var F2 = 0.5*(Math.sqrt(3)-1);
  var G2 = (3-Math.sqrt(3))/6;

  var F3 = 1/3;
  var G3 = 1/6;

  // 2D simplex noise
  module.simplex2 = function(xin, yin) {
    var n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin)*F2; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var t = (i+j)*G2;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      i1=1; j1=0;
    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      i1=0; j1=1;
    }
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    var y1 = y0 - j1 + G2;
    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
    var y2 = y0 - 1 + 2 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    i &= 255;
    j &= 255;
    var gi0 = gradP[i+perm[j]];
    var gi1 = gradP[i+i1+perm[j+j1]];
    var gi2 = gradP[i+1+perm[j+1]];
    // Calculate the contribution from the three corners
    var t0 = 0.5 - x0*x0-y0*y0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.5 - x1*x1-y1*y1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    var t2 = 0.5 - x2*x2-y2*y2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot2(x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70 * (n0 + n1 + n2);
  };

  // 3D simplex noise
  module.simplex3 = function(xin, yin, zin) {
    var n0, n1, n2, n3; // Noise contributions from the four corners

    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin+zin)*F3; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var k = Math.floor(zin+s);

    var t = (i+j+k)*G3;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    var z0 = zin-k+t;

    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
    // Determine which simplex we are in.
    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
    if(x0 >= y0) {
      if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
      else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
      else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
    } else {
      if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
      else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
      else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
    }
    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
    // c = 1/6.
    var x1 = x0 - i1 + G3; // Offsets for second corner
    var y1 = y0 - j1 + G3;
    var z1 = z0 - k1 + G3;

    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
    var y2 = y0 - j2 + 2 * G3;
    var z2 = z0 - k2 + 2 * G3;

    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
    var y3 = y0 - 1 + 3 * G3;
    var z3 = z0 - 1 + 3 * G3;

    // Work out the hashed gradient indices of the four simplex corners
    i &= 255;
    j &= 255;
    k &= 255;
    var gi0 = gradP[i+   perm[j+   perm[k   ]]];
    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];
    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];
    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];

    // Calculate the contribution from the four corners
    var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
    }
    var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
    }
    var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
    if(t3<0) {
      n3 = 0;
    } else {
      t3 *= t3;
      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 32 * (n0 + n1 + n2 + n3);

  };

  // ##### Perlin noise stuff

  function fade(t) {
    return t*t*t*(t*(t*6-15)+10);
  }

  function lerp(a, b, t) {
    return (1-t)*a + t*b;
  }

  // 2D Perlin Noise
  module.perlin2 = function(x, y) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y);
    // Get relative xy coordinates of point within that cell
    x = x - X; y = y - Y;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255;

    // Calculate noise contributions from each of the four corners
    var n00 = gradP[X+perm[Y]].dot2(x, y);
    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);

    // Compute the fade curve value for x
    var u = fade(x);

    // Interpolate the four results
    return lerp(
        lerp(n00, n10, u),
        lerp(n01, n11, u),
       fade(y));
  };

  // 3D Perlin Noise
  module.perlin3 = function(x, y, z) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);
    // Get relative xyz coordinates of point within that cell
    x = x - X; y = y - Y; z = z - Z;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255; Z = Z & 255;

    // Calculate noise contributions from each of the eight corners
    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);
    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);
    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);
    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);
    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);
    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);
    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);
    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);

    // Compute the fade curve value for x, y, z
    var u = fade(x);
    var v = fade(y);
    var w = fade(z);

    // Interpolate
    return lerp(
        lerp(
          lerp(n000, n100, u),
          lerp(n001, n101, u), w),
        lerp(
          lerp(n010, n110, u),
          lerp(n011, n111, u), w),
       v);
  };

})(this);

;
//PARAMS
var T = 0 //Starttimestamp in ms since 1970
var X = 0 //Avatar X Position in grid coord
var Y = 0 //Avatar Y Position in grid coord
var _X = 0
var _Y = 0
var Z = 0
var A = 0 //View Angle, relative 0-1
var R = 0 //Rotation Angle, relative 0-1
var C = "#ffffff"
//FLAGS
var POINTER_FLAG = false //Used to determine if the user is currently holding the mouse/finger down
var INFO_FLAG = 0 //stores the state of the info popup. 1 = Popup open, 0 = Popup closed, -X = Popup closed, may not open. Will be reset to negative INFO_CD
var USER_HAS_MOVED_AFTER_CLOSE = false //stores wether the user has moved after a popup was closed
//TIMERS
var MOVE_INTERVAL = false //Stores reference to the interval used for user movement
var INFO_INTERVAL = false //Stores reference to the interval that is used to display the info popup conditionally
var UI_UPDATE_CLOCK = 0
//RAM
var LAST_POINTER = {x:0,y:0} //Stores the coordinates of the last pointer that was registered
var LAST_POINTER_TIMESTAMP = 0 //Stores the timestamp of the last touch/click
var POINTER_ROTATION = {x:0,y:0,z:0} //Stores the basis for the 3d rotation based on the pointer
var POINTER_ROTATION_DELTA = {x:0,y:0,z:0} //Stores a momentary difference in pointer position relative to POINTER_ROTATION as a base
//ENV
const FPS = 12 //target framerate
const UNIT = 60 //virtual grid units to onscreen units
const FOV = 12 //size of the displayed grid
const SPEED = 0.9 //moving speed in grid units per second
var LIMES = 0 //virtual border for repeating objects, set dynamically
const SPACING = FOV //average spacing between pillars
const SEED = 42069
const UPDATE_UI_AFTER = 10
const INFO_CD = 10
const JOIN_SPREAD = FOV
const INFO_AREA = 3
const COLOR_POOL = [ //list of preselected colors the user AVATAR is randomly assigned
      "#87cded","#0165fc","#41fdfe","#1974d2","#24a0ed","#1ac1dd","#c4fff7","#7df9ff","#3f00ff","#00fdff","#1166ff","#15f2fd","#04d9ff","#0203e2","#0044ff","#00bffe","#010fcc","#d0ff14","#8cff9e","#cfff00","#66ff00","#87fd05","#9dff00","#c1f80a","#21fc0d","#08ff08","#00ff00","#aeff6e","#53fe5c","#56fca2","#4efd54","#aaff32","#7af9ab","#a0d404","#00fa9a","#45cea2","#39ff14","#77dd77","#19a700","#68e52f","#7ded17","#00f900","#00ff7c","#06c2ac","#0add08","#2fef10","#fea051","#fe6700","#ff7034","#ffc82a","#ff7124","#eb5030","#ed872d","#fd6f3b","#ffa600","#ee8800","#ff7f50","#ffa812","#fc642d","#ff3503","#ffcf00","#eb6123","#ff8d28","#ffa62b","#f08300","#ffa368","#ff9889","#ff9933","#ff5721","#ffa500","#ff7f00","#ffa000","#ff6f52","#fa5b3d","#fc845d","#ff7518","#fc9e21","#ff6600","#ff9300","#ff7420","#ff5f00","#fe01b1","#ff85ff","#ff7fa7","#d90166","#f4bfff","#ff0490","#fe1493","#fd3f92","#ee6d8a","#ff00cc","#ff028d","#ffb3de","#ff00ff","#ff2feb","#fe4164","#fe019a","#ff66ff","#ff1476","#f62681","#d648d7","#df4ec8","#e25098","#f6688e","#ca2c92","#fe02a2","#ff1cae","#ff6ffc","#ff878d","#f06fff","#fb5ffc","#be03fd","#ad0afd","#6600ff","#bf00ff","#8f00f1","#cb00f5","#b56edc","#bc13fe","#e0b0ff","#65318e","#b80ce3","#9f00ff","#ff000d","#e30022","#f7022a","#f2013f","#ff4040","#e60000","#d01c1f","#fe0002","#ff5555","#eb5406","#fd5956","#f1172f","#cf1020","#bc2731","#fc2847","#ff073a","#ff1b2d","#fe4401","#f43605","#f10c45","#d22d1d","#b0054b","#dd1133","#b00149","#e30b5d","#ff0000","#ee204d","#ff3f34","#fa2a55","#e40078","#fe2713","#f8481c","#fe2c54","#ca0147","#ff2400","#bb1237","#d73c26","#ff1111","#ec2d01","#b21807","#fd0d35","#bf1932","#c6174e","#ef3939","#cc0033","#ff006c","#f70d1a","#e56024","#eddd59","#fffc79","#fffd01","#ffff81","#fff600","#fcfc5d","#fcd116","#ffff31","#fedf08","#ffff33","#fffc00","#ffd700","#fff700","#f1ff62","#f0e681","#cfff04","#d1e231","#ffc324","#fada50","#eed202","#f4c430","#ffd800","#f7b718","#e8ff2a","#ffdc41","#dfff4f","#ffe302","#f7c114","#ffff00","#ffef00","#ffff11","#ffcc3a","#fcfd74","#fff000","#ffff14"]
//OBJECTS
const PLAYER = {
  colors: [],
  shapes: [[0.11,0.22,0.33,0.44,0.55,0.66,0.77,0.88,0.99],[0.99,0.88,0.77,0.66,0.55,0.44,0.33,0.22,0.11]]
}
var PILLARS = []
var POI_IN_VIEW = []

//GLOBALS
const G = {
  openInfo: function(poi,force){
    if(!INFO_FLAG || force){
      USER_HAS_MOVED_AFTER_CLOSE = false
      INFO_FLAG = 1
      UI.title.innerText = poi.name
      if(poi.artists){
        UI.artists.innerText = poi.artists
        UI.artists.style.display = "block"
      }
      else{
        UI.artists.style.display = "none"
      }
      if(poi.date){
        UI.date.innerText = poi.date
        UI.date.style.display = "block"
      }
      else{
        UI.date.style.display = "none"
      }
      UI.desc.innerHTML = poi.description
      if(poi.link){
        UI.link.setAttribute("data-href",poi.link)
        if(poi.noconnect){
          UI.link.setAttribute("data-noconnect",true)
        }
        else{
          UI.link.setAttribute("data-noconnect",false)
        }
        if(poi.exhibit){
          UI.link.setAttribute("data-target","exhibit")
        }
        else{
          UI.link.setAttribute("data-target","external")
        }
        UI.container.classList.remove("no-link")
      }
      else{
        UI.container.classList.add("no-link")
      }
      if(poi.linktitle){
        UI.link.innerText = poi.linktitle
      }
      else{
        UI.link.innerText = "Enter"
      }
      document.body.classList.add("info-open")
    }
  },
  closeInfo: function(){
    document.body.classList.remove("info-open")
    INFO_FLAG = -INFO_CD
  },
  openLink: function (e){
    let link = document.getElementById("infoOpen")
    let target = link.getAttribute("data-target")
    let href = link.getAttribute("data-href")
    let noconnect = link.getAttribute("data-noconnect") == "true"
    if(target == "external"){
      window.open(href, '_blank')
    }
    else if(target == "exhibit"){
      document.body.classList.remove("curtain-open")
      setTimeout(function () {
        let x = Math.round((LIMES + (_X % LIMES)) % LIMES)
        let y = Math.round((LIMES + (_Y % LIMES)) % LIMES)
        window.location.href = noconnect ? href : href + "?color=" + COLOR.replace("#","") + "&x=" + x  + "&y=" + y
      }, 1500);
    }
  },
  toggleMenu: function(){
    document.body.classList.toggle("menu-open")
  },
  openInfoDirect: function(target,forcePoi){
    if(forcePoi){
      G.openInfo(forcePoi,true)
      document.body.classList.remove("menu-open")
      document.body.classList.remove("tutorial-open")
    }
    else{
      let poi = false
      if(typeof target === "object"){
        poi = target
      }
      else{
        for(let _p in PILLARS){
          let p = PILLARS[_p]
          if(p.id == target){
            poi = p
          }
        }
      }
      if(poi){
        G.openInfo(poi,true)
        document.body.classList.remove("menu-open")
        document.body.classList.remove("tutorial-open")
      }
    }

  }
}
//UI
const UI = {
  connect: function(){
    this.x = document.getElementById("avatarX")
    this.y = document.getElementById("avatarY")
    this.colorA = document.getElementById("avatarFirstColor")
    this.colorB = document.getElementById("avatarSecondColor")
    this.container = document.getElementById("info")
    this.title = document.getElementById("infoTitle")
    this.artists = document.getElementById("infoArtists")
    this.date = document.getElementById("infoDate")
    this.desc = document.getElementById("infoDesc")
    this.link = document.getElementById("infoOpen")
    this.pois = document.getElementById("outputPOI")
  },
  events: function(){
    document.getElementById("aboutLink").addEventListener("click",() => G.openInfoDirect('about'))
    document.getElementById("fundersLink").addEventListener("click",() => G.openInfoDirect('funders'))
    document.getElementById("programLink").addEventListener("click",() => G.openInfoDirect('program',))
    document.getElementById("archiveLink").addEventListener("click",() => G.openInfoDirect('archive',))
    document.getElementById("logos").addEventListener("click",() => G.openInfoDirect('funders'))
    document.getElementById("menubutton").addEventListener("click",() => G.toggleMenu())
    document.getElementById("infoOpen").addEventListener("click",() => G.openLink())
    document.getElementById("infoExit").addEventListener("click",() => G.closeInfo())
  },
  init: function(){
    this.connect()
    this.events()
  },
  update: function(){
    let time = Math.floor(performance.now() / 1000) //gets the time since join
    this.x.innerText = Math.round((LIMES + (_X % LIMES)) % LIMES) //updates x position
    this.y.innerText = Math.round((LIMES + (_Y % LIMES)) % LIMES) //updates y position
    this.pois.innerHTML = "" //resets the poilist
    for(let POIS in POI_IN_VIEW){ //for every POI in view
      let tr = document.createElement("tr") //creates a tr wrapper
      let th = document.createElement("th") //creates a th for title
      let td = document.createElement("td") //creates a td for colorcode
      let a = document.createElement("a") //creates a link
      a.addEventListener("mousedown",e => {G.openInfoDirect(POI_IN_VIEW[POIS])}) //attaches event handler to wrapper
      let name = POI_IN_VIEW[POIS].name
      a.innerText = name.substring(0,20) + (name.length > 20 ? "..." : "")//sets linktitle to poi title
      for(let c in POI_IN_VIEW[POIS].pillar.colors){ //iterates over all colors in plan
        let span = document.createElement("span") //creates a span to hold show the color value
        span.classList.add("color") //adds class to span for css
        span.style.background = M.rgbToHex(POI_IN_VIEW[POIS].pillar.colors[c]) //sets background inline
        td.appendChild(span) //appends to data
      }
      tr.appendChild(td) //appends data before th to row so its is displayed on the left
      th.appendChild(a) //appends link to th
      tr.appendChild(th) //appends th
      this.pois.appendChild(tr) //appends row to list
    }
  }
}
//INPUTS
const I = {
  init: function(){
    window.addEventListener("mousemove",function(e){
      I.handleRotate(e.clientX,e.clientY)
    })
    window.addEventListener("touchmove", function(e){
      I.handleRotate(e.targetTouches[0].clientX,e.targetTouches[0].clientY)
    })
    window.addEventListener("mousedown",function(e){
      I.pointerDown(e.clientX,e.clientY)
    })
    window.addEventListener("touchstart",function(e){
      I.pointerDown(e.targetTouches[0].clientX,e.targetTouches[0].clientY)
    })
    window.addEventListener("mouseup",I.pointerUp)
    window.addEventListener("touchend",I.pointerUp)
  },
  pointerDown: function(x,y){
    document.body.classList.remove("tutorial-open")
    LAST_POINTER_TIMESTAMP = performance.now()
    if(!POINTER_FLAG && INFO_FLAG != 1){
      LAST_POINTER = {x:x,y:y}
      POINTER_FLAG = true
      if(!MOVE_INTERVAL){
        MOVE_INTERVAL = true
        USER_HAS_MOVED_AFTER_CLOSE = true
      }
    }
  },
  pointerUp: function(){
    if(POINTER_FLAG){
      POINTER_ROTATION.z += POINTER_ROTATION_DELTA.z
      POINTER_ROTATION.x += POINTER_ROTATION_DELTA.x
      POINTER_ROTATION_DELTA = {x:0,y:0,z:0}
      POINTER_FLAG = false
      MOVE_INTERVAL = false
    }
  },
  handleRotate: function (x,y){
    if(INFO_FLAG != 1){
      if(POINTER_FLAG){
        let dX =  (LAST_POINTER.x - x) / window.innerWidth
        let dY =  (LAST_POINTER.y - y) / window.innerHeight
        POINTER_ROTATION_DELTA.z = dX
        POINTER_ROTATION_DELTA.x = (-0.5 < (POINTER_ROTATION.x + dY) && (POINTER_ROTATION.x + dY) < 0.5) ? dY : (POINTER_ROTATION.x + dY) > 0.5 ? 0.5 - POINTER_ROTATION.x : -0.5 - POINTER_ROTATION.x
      }
    }
  }
}
//PROJECTIONMATRIX
const M = {
  hexToRgb: function(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [parseInt(result[1], 16),parseInt(result[2], 16),parseInt(result[3], 16)] : [0,0,0]
  },
  rgbToHex: function(rgb) {
    function componentToHex(c) {
      var hex = c.toString(16);
      return hex.length == 1 ? "0" + hex : hex;
    }
    return "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);
  },
  invertHex: function(hex){ //inverts given hex color
    hex = hex.replace("#","")
    return "#" + (Number(`0x1${hex}`) ^ 0xFFFFFF).toString(16).substr(1).toUpperCase()
  },
  randomColor: function(){ //returns a random color from color pool
      return COLOR_POOL[Math.floor(COLOR_POOL.length * Math.random())]
  },
  shapes: {
    ball: [
      0.5848248826150173,
      0.8017403630144483,
      0.9306048591020996,
      0.9923748047044564,
      0.9923748047044564,
      0.9306048591020997,
      0.8017403630144484,
      0.5848248826150174
    ],
    cube: [ 1, 1],
    space: [ 0, 0],
    drum: [ 0.66, 0.66],
    cone: [
      0.1111111111111111,
      0.2222222222222222,
      0.3333333333333333,
      0.4444444444444444,
      0.5555555555555556,
      0.6666666666666666,
      0.7777777777777778,
      0.8888888888888888
    ],
    funnel: [
      0.8888888888888888,
      0.7777777777777778,
      0.6666666666666667,
      0.5555555555555556,
      0.4444444444444444,
      0.33333333333333337,
      0.2222222222222222,
      0.11111111111111116
    ]
  },
  shapeFromIndex: function(i){
    switch(i){
      case 1:
        return this.shapes.cube
      case 2:
        return this.shapes.cone
      case 3:
        return this.shapes.funnel
      case 4:
        return this.shapes.ball
      case 5:
        return this.shapes.drum
      default:
        return this.shapes.space

    }
  },
  radToDeg: function(r) {
    return r * 180 / Math.PI;
  },
  degToRad: function(d) {
    return d * Math.PI / 180;
  },
  projection: function(width, height, depth) {
    // Note: This matrix flips the Y axis so 0 is at the top.
    return [
       2 / width, 0, 0, 0,
       0, -2 / height, 0, 0,
       0, 0, 2 / depth, 0,
      -1, 1, 0, 1,
    ];
  },

  multiply: function(a, b) {
    var a00 = a[0 * 4 + 0];
    var a01 = a[0 * 4 + 1];
    var a02 = a[0 * 4 + 2];
    var a03 = a[0 * 4 + 3];
    var a10 = a[1 * 4 + 0];
    var a11 = a[1 * 4 + 1];
    var a12 = a[1 * 4 + 2];
    var a13 = a[1 * 4 + 3];
    var a20 = a[2 * 4 + 0];
    var a21 = a[2 * 4 + 1];
    var a22 = a[2 * 4 + 2];
    var a23 = a[2 * 4 + 3];
    var a30 = a[3 * 4 + 0];
    var a31 = a[3 * 4 + 1];
    var a32 = a[3 * 4 + 2];
    var a33 = a[3 * 4 + 3];
    var b00 = b[0 * 4 + 0];
    var b01 = b[0 * 4 + 1];
    var b02 = b[0 * 4 + 2];
    var b03 = b[0 * 4 + 3];
    var b10 = b[1 * 4 + 0];
    var b11 = b[1 * 4 + 1];
    var b12 = b[1 * 4 + 2];
    var b13 = b[1 * 4 + 3];
    var b20 = b[2 * 4 + 0];
    var b21 = b[2 * 4 + 1];
    var b22 = b[2 * 4 + 2];
    var b23 = b[2 * 4 + 3];
    var b30 = b[3 * 4 + 0];
    var b31 = b[3 * 4 + 1];
    var b32 = b[3 * 4 + 2];
    var b33 = b[3 * 4 + 3];
    return [
      b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
      b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
      b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
      b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
      b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
      b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
      b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
      b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
      b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
      b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
      b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
      b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
      b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
      b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
      b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
      b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,
    ];
  },

  translation: function(tx, ty, tz) {
    return [
       1,  0,  0,  0,
       0,  1,  0,  0,
       0,  0,  1,  0,
       tx, ty, tz, 1,
    ];
  },

  xRotation: function(angleInRadians) {
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    return [
      1, 0, 0, 0,
      0, c, s, 0,
      0, -s, c, 0,
      0, 0, 0, 1,
    ];
  },

  yRotation: function(angleInRadians) {
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    return [
      c, 0, -s, 0,
      0, 1, 0, 0,
      s, 0, c, 0,
      0, 0, 0, 1,
    ];
  },

  zRotation: function(angleInRadians) {
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    return [
       c, s, 0, 0,
      -s, c, 0, 0,
       0, 0, 1, 0,
       0, 0, 0, 1,
    ];
  },

  scaling: function(sx, sy, sz) {
    return [
      sx, 0,  0,  0,
      0, sy,  0,  0,
      0,  0, sz,  0,
      0,  0,  0,  1,
    ];
  },

  translate: function(m, tx, ty, tz) {
    return M.multiply(m, M.translation(tx, ty, tz));
  },

  xRotate: function(m, angleInRadians) {
    return M.multiply(m, M.xRotation(angleInRadians));
  },

  yRotate: function(m, angleInRadians) {
    return M.multiply(m, M.yRotation(angleInRadians));
  },

  zRotate: function(m, angleInRadians) {
    return M.multiply(m, M.zRotation(angleInRadians));
  },
  vRotate: function(v, angleInDegrees){
    let ang = -angleInDegrees * (Math.PI/180);
    let cos = Math.cos(ang);
    let sin = Math.sin(ang);
    return new Array(Math.round(10000*(v[0] * cos - v[1] * sin))/10000, Math.round(10000*(v[0] * sin + v[1] * cos))/10000);
  },
  scale: function(m, sx, sy, sz) {
    return M.multiply(m, M.scaling(sx, sy, sz));
  },

};



//MAIN
function main() {
  noise.seed(0)
  I.init()
  UI.init()
  T = Date.now()
  initPillars()
  const urlParams = new URLSearchParams(window.location.search) //gets any url parameters
  let color = urlParams.get('color') ? "#" + urlParams.get('color') : M.randomColor() //either stores the color given by url parameter or generates a random one when none is given
  let position = urlParams.get('x') && urlParams.get('y') ? {x:Number(urlParams.get('x')),y:Number(urlParams.get('y'))} : {x:noise.simplex2(performance.now(),10000)*JOIN_SPREAD,y:noise.simplex2(10000,performance.now())*JOIN_SPREAD} //either stores the position given by url parameter or generates a random one when none is given
  const flag = urlParams.get("color") && urlParams.get("x") && urlParams.get("y") //if all params are present
  let anchor = window.location.href.split('#').pop()
  let poi = urlParams.get('poi') ? urlParams.get('poi').toLowerCase() : anchor ? anchor.toLowerCase() : false //gets poi param or false
  let found = false //search result flag
  if(poi){ //when a param was present
  for(let _p in PILLARS){ //for every poi
    let p = PILLARS[_p]
      if(!found && (p.name.toLowerCase() == poi || p.id.toLowerCase() == poi)){ //if none was found yet and the poi matches with id or name
        poi = p //stores reference
        found = true //sets flag
      }
    }
  }
  if(!found){ //when none was found
    poi = false //reset poi to false, param was present but no poi could be identified
  }
  if(!flag){ //when not all parameters are present
    document.body.classList.add("tutorial-open") //show the tutorial
  }
  if(poi){ //when a poi was found
    X = poi.x - FOV * 0.5 + 2//set avatar pos
    Y = poi.y - FOV * 0.5
    G.openInfoDirect(poi) //open the pois info
  }
  else{
    X = position.x
    Y = position.y
  }

  _X = Math.floor(X)
  _Y = Math.floor(Y)
  let cA = color
  let cB = M.invertHex(color)
  UI.colorA.style.background = cA
  UI.colorB.style.background = cB
  PLAYER.colors = [M.hexToRgb(cA),M.hexToRgb(cB)]

  var canvas = document.querySelector("#canvas")
  var gl = canvas.getContext("webgl")
  if (!gl) {
    return
  }
  var program = webglUtils.createProgramFromScripts(gl, ["vertex-shader-3d", "fragment-shader-3d"])
  var positionLocation = gl.getAttribLocation(program, "a_position")
  var colorLocation = gl.getAttribLocation(program, "a_color")
  var matrixLocation = gl.getUniformLocation(program, "u_matrix")
  document.body.classList.add("curtain-open")
  initInfoInterval()
  render() //first rendercall
  function initPillars(){
    PILLARS = mapPillarArray(displacePillarsAndSetLimes(parseContentToPillars(),SPACING))
  }
  function parseContentToPillars(){
    let content = document.getElementById("content")
    let pillars = [].slice.call(content.getElementsByClassName("pillar"))
    let r = []
    for(let _p in pillars){
      let p = pillars[_p]
      let title = [].slice.call(p.getElementsByClassName("pillar_title"))[0].innerText
      let id = p.getAttribute("data-id")
      let pillar = p.getAttribute("data-pillar") ? JSON.parse(p.getAttribute("data-pillar")) : false
      let dateNode = [].slice.call(p.getElementsByClassName("pillar_date"))[0] //optional
      let date = dateNode ? dateNode.innerText : false
      let artistsNode = [].slice.call(p.getElementsByClassName("pillar_artists"))[0] //optional
      let artists = artistsNode ? artistsNode.innerText : false
      let description = [].slice.call(p.getElementsByClassName("pillar_description"))[0].innerText
      let linkNode = [].slice.call(p.getElementsByClassName("pillar_link"))[0] //optional
      let linktarget = linkNode ? linkNode.getAttribute("href") : false
      let linktitle = linkNode ? linkNode.innerText : false
      let exhibit = p.getAttribute("data-poi") == null
      let poi = p.getAttribute("data-type") != "illusions"
      r.push({
        name: title,
        id: id,
        artists: artists,
        date: date,
        description: description,
        link: linktarget,
        linktitle: linktitle,
        exhibit: exhibit,
        pillar: pillar,
        poi: poi
      })
    }
    return r
  }
  function mapPillarArray(array){
    let obj = {}
    for(let i in array){
      let index = array[i]
      for(let s in index.pillar.shapes){
        let shape = index.pillar.shapes[s]
        index.pillar.shapes[s] = M.shapeFromIndex(shape)
      }
      for(let c in index.pillar.colors){
        let color = index.pillar.colors[c]
        if(typeof color != "object"){
          index.pillar.colors[c] = M.hexToRgb(color)
        }
      }
      let key = index.poi ? index.x + ";" + index.y : index.id
      obj[key] = index
    }
    return obj
  }
  function displacePillarsAndSetLimes(array,spacing){
    let m = 0.2
    let tX = 0
    let tY = 0
    let mX = 0
    let l = Math.ceil(Math.sqrt(array.length))
    for(let y = 0; y < l; y++){
      tY += Math.round((m + ((1+noise.simplex2(SEED,y*10000))*0.5)*(1-m)) * spacing)
      for(let x = 0; x < l; x++){
        let p = y * l + x
        if(array[p]){
          let pillar = array[p]
          tX += Math.round((m + ((1+noise.simplex3(x*10000,y*10000,SEED))*0.5)*(1-m)) * spacing)
          pillar.x = tX
          pillar.y = tY
          array[p] = pillar
        }
      }
      if(tX > mX){
        mX = tX
      }
      tX = 0
    }
    LIMES = Math.max(mX,tY) + Math.round(spacing * m)
    return array
  }

  // Draw the scene.
  function render() {
    R =  (0.55 + (1 - ((1 - ((POINTER_ROTATION.z+POINTER_ROTATION_DELTA.z) % 1)) % 1))) % 1
    A = POINTER_ROTATION.x+POINTER_ROTATION_DELTA.x
    if(MOVE_INTERVAL){
      let v = M.vRotate([0,-1],180 + R*360)
      X += v[0] * SPEED
      Y += v[1] * SPEED
      _X = Math.floor(X)
      _Y = Math.floor(Y)
      Z += SPEED * (v[0] + v[1])
    }
    let t = Date.now() - T //calcs timestamp since start
    rotation = [M.degToRad(125-25*A), M.degToRad(0), M.degToRad(R*360)]
    translation = [window.innerWidth*0.5, window.innerHeight*0.7, 1]
    let s = window.innerWidth / 1920 * Math.max(1,window.innerHeight / window.innerWidth * 2) * (0.8 + 0.2 * A)
    var scale = [s,s,s] //3d scale
    var positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    let objects = generateGeometryAndReturnObjects(gl)
    let obj = objects.obj
    POI_IN_VIEW = obj
    let objectColors = objects.objectColors
    var colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    setColors(gl,objectColors);
    webglUtils.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.useProgram(program);
    gl.enableVertexAttribArray(positionLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    var size = 3;          // 3 components per iteration
    var type = gl.FLOAT;   // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
    gl.enableVertexAttribArray(colorLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    var size = 3;                 // 3 components per iteration
    var type = gl.UNSIGNED_BYTE;  // the data is 8bit unsigned values
    var normalize = true;         // normalize the data (convert from 0-200 to 0-1)
    var stride = 0;               // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;               // start at the beginning of the buffer
    gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset);
    var matrix = M.projection(gl.canvas.clientWidth, gl.canvas.clientHeight, Math.max(gl.canvas.clientHeight,gl.canvas.clientWidth));
    matrix = M.translate(matrix, translation[0], translation[1], translation[2]);
    matrix = M.xRotate(matrix, rotation[0]);
    matrix = M.yRotate(matrix, rotation[1]);
    matrix = M.zRotate(matrix, rotation[2]);
    matrix = M.scale(matrix, scale[0], scale[1], scale[2]);
    gl.uniformMatrix4fv(matrixLocation, false, matrix);
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = FOV * FOV * 6 * 2 + objects.polygonCount * 6;
    gl.drawArrays(primitiveType, offset, count)
    UI_UPDATE_CLOCK++ //ups the UI update clock
    if(UI_UPDATE_CLOCK == UPDATE_UI_AFTER ){ //when the clock is to be reset
      UI_UPDATE_CLOCK = 0 //resets the clock
      UI.update() //calls update on the UI
    }
    let rendertime = Date.now() - T - t //the time it took for the whole rendercall to run through
    setTimeout(render, 1000 / FPS - rendertime) //call render recursive with target fps for timeout
  }
  function generateGeometryAndReturnObjects(gl) {
    let faces = []
    let lines = []
    let objects = []
    let objectColors = []
    let lineWidth = 0.05
    let iY = ((0.25 + R) % 1) < 0.5  //when rotation between 45 and 225 invert y
    let iX = ((0.5 + R) % 1) > 0.5  //when rotation between 135 and 315 invert x
    let fX = iX ? FOV-1 : 0 //floorvalue for x
    let fY = iY ? FOV-1 : 0 //floorvalue for y
    let x = fX //real value for x
    let y = fY //floor and real value for y
    let cX = iX ? -1 : FOV //ceiling value for x
    let cY = iY ? -1 : FOV//ceiling value for y
    let pX = Math.floor(FOV * 0.5) //player x pos
    let pY = Math.floor(FOV * 0.5) //player y pos
    let dX = iX ? -1 : 1//delta for x
    let dY = iY ? -1 : 1 //delta for y
    let obj = {}
    let objPolygons = 0

    let __X = (LIMES - (_X % LIMES)) % LIMES
    let __Y = (LIMES - (_Y % LIMES)) % LIMES
    while(y != cY){  //will detect all objects in view
      x = fX
      while(x != cX){
        let _x = (x + LIMES - __X) % LIMES
        let _y = (y + LIMES - __Y) % LIMES
        let key = _x + ";" + _y
        if(PILLARS[key] != undefined){
          obj[x + ";" + y] = PILLARS[key]
        }
        x += dX
      }
      y += dY
    }
    y = fY
    while(y != cY){
      x = fX
      while(x != cX){
        let _x = x //we store backups of virutal coordinate for Z value generation and object detection
        let _y = y
        x -= X % 1 //real position coordinates take remainder of player movememnt into account
        y -= Y % 1
        if(obj[_x + ";" + _y]){
          let z = getLowestZ(_X+_x,_Y+_y) + 0.2
          let object = obj[_x + ";" + _y]
          renderObjectShapes(x,y,z,object.pillar)
        }
        if(_x == pX && _y == pY){
          let z = Z(_x-0.5,_y-0.5) + 1.5 + Math.sin(performance.now() * 0.0005) * 0.5
          let object = PLAYER
          renderObjectShapes(x-0.5,y-0.5,z,object)
        }
        faces = faces.concat([
          -FOV*0.5*UNIT+x*UNIT+lineWidth*UNIT, -FOV*0.5*UNIT+y*UNIT+lineWidth*UNIT, Z(_x+_X,_y+_Y)*UNIT, //topleft
          -FOV*0.5*UNIT+x*UNIT+lineWidth*UNIT, -FOV*0.5*UNIT+(y+1)*UNIT-lineWidth*UNIT, Z(_x+_X,_y+1+_Y)*UNIT, //bottomleft
          -FOV*0.5*UNIT+(x+1)*UNIT-lineWidth*UNIT, -FOV*0.5*UNIT+y*UNIT+lineWidth*UNIT, Z(_x+1+_X,_y+_Y)*UNIT, //topright
          -FOV*0.5*UNIT+x*UNIT+lineWidth*UNIT, -FOV*0.5*UNIT+(y+1)*UNIT-lineWidth*UNIT, Z(_x+_X,_y+1+_Y)*UNIT, //bottomleft
          -FOV*0.5*UNIT+(x+1)*UNIT-lineWidth*UNIT, -FOV*0.5*UNIT+(y+1)*UNIT-lineWidth*UNIT, Z(_x+1+_X,_y+1+_Y)*UNIT, //bottomright
          -FOV*0.5*UNIT+(x+1)*UNIT-lineWidth*UNIT, -FOV*0.5*UNIT+y*UNIT+lineWidth*UNIT, Z(_x+1+_X,_y+_Y)*UNIT, //topright
        ])
        lines = lines.concat([
          -FOV*0.5*UNIT+x*UNIT, -FOV*0.5*UNIT+y*UNIT, Z(_x+_X,_y+_Y)*UNIT,
          -FOV*0.5*UNIT+x*UNIT, -FOV*0.5*UNIT+(y+1)*UNIT, Z(_x+_X,_y+1+_Y)*UNIT,
          -FOV*0.5*UNIT+(x+1)*UNIT, -FOV*0.5*UNIT+y*UNIT, Z(_x+1+_X,_y+_Y)*UNIT,
          -FOV*0.5*UNIT+x*UNIT, -FOV*0.5*UNIT+(y+1)*UNIT, Z(_x+_X,_y+1+_Y)*UNIT,
          -FOV*0.5*UNIT+(x+1)*UNIT, -FOV*0.5*UNIT+(y+1)*UNIT, Z(_x+1+_X,_y+1+_Y)*UNIT,
          -FOV*0.5*UNIT+(x+1)*UNIT, -FOV*0.5*UNIT+y*UNIT, Z(_x+1+_X,_y+_Y)*UNIT,
        ])
        x = _x //reset looping coordinates back to stored values
        y = _y
        x += dX
      }
      y += dY
    }
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(lines.concat(faces).concat(objects)),gl.STATIC_DRAW)
    function Z(x,y){ //will return elevation z for point x,y
      let s = 0.00005
      let g = 0.2
      let d = 0.01
      let e = Math.round( ((1 + noise.simplex2(10000+x*d,10000+y*d)) * 0.5) * 9)
      switch(e){
        case 0: //water
          return (1 + Math.sin(y + performance.now() * s)) * 0.5
        case 1: //moving planes
          return (1 + noise.simplex3(x*g,y*g,performance.now() * s)) * 0.5
        case 2: //wide plane
          return (1 + noise.simplex2(x*g,y*g) * 0.5)
        case 3: //moving plane
          return (1 + noise.simplex3(x*g*0.1,y*g*0.1,performance.now() * s*0.5)) * 0.5
        case 4: //plane
          return 0
        case 5: //craters
         return noise.simplex2(x*g,y*g) > 0.5 ? 0 : 1
        case 6:  //geometry hills
          return noise.simplex2((x*g*0.2)%2,(y*g*0.2)%2) < 0 ? 0 : 1
        case 7: //hills
          return Math.round(Math.pow((1 + noise.simplex2(x*g,y*g) * 0.5),3) * 3) * 0.333 * 0.5
        case 8: //mountains
          return  Math.pow((1 + noise.simplex2(x*g,y*g) * 0.5),3)
        case 9: //moving mountains
          return Math.pow((1 + noise.simplex3(x*g,y*g,performance.now() * s) * 0.5),3)
      }
    }
    function getLowestZ(x,y){
      return Math.max(Z(x,y),Z(x+1,y),Z(x,y+1),Z(x+1,y+1))
    }
    function mixPillarColor(progress,colors){
      if(colors.length == 1){
        return colors[0]
      }
      else{
        let _p = Math.floor((colors.length-1) * progress)
        let fC = colors[_p]
        let cC = colors[_p +1]
        let rP = progress * (colors.length-1) % 1
        let c = [fC[0]*(1-rP)+cC[0]*rP,fC[1]*(1-rP)+cC[1]*rP,fC[2]*(1-rP)+cC[2]*rP]
        return c
      }
    }
    function renderObjectShapes(x,y,z,object){
      for(let s = 0; s < object.shapes.length;s++){
        let c =  Math.floor(object.colors.length / object.shapes.length)
        let _x = 0
        let _y = 0
        let _z = 0
        let o = {
          shapes: object.shapes[s],
          colors:[object.colors[s*c],object.colors[s*c+c-1]]
        }
        if(object.animations){
          if(object.animations[""+s]){
            let a = object.animations[""+s]
            let sp = a.speed || 1
            let aP = (performance.now() * 0.0001 / sp) % 1
            let rP = (aP * (a.keys.length-1)) % 1

            let k = Math.floor(aP * (a.keys.length-1))
            let fK = a.keys[k]
            let cK = a.keys[k+1]
            _x = fK.x * (1-rP) + cK.x * rP
            _y = fK.y * (1-rP) + cK.y * rP
            _z = fK.z * (1-rP) + cK.z * rP
          }
        }
        renderObject(o,x+_x,y+_y,z+s+_z,[1,1])
      }
    }
    function renderObject(value,x,y,z,scale,flat){
      const h = scale[1]
      let stepheight = 1 / value.shapes.length
      for(let s = 0; s < value.shapes.length; s++){
        let step = value.shapes[s]
        let stepD = (1-step) * 0.5 * scale[1]
        if(step != 0){
          let fH = s * stepheight * h
          let cH = (s+1) * stepheight * h
          if(flat){
            let color = value.colors[0]
            objects = objects.concat([
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side1 topright-topleft
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,

              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side2 topleft-bottomleft
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT, //side3 bottomleft-bottomright
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side4 bottomright-topright
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topleft //top
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
              -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomright
              -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
            ])
            objectColors.push(

              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],

              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],

              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],

              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],

              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
              color[0],color[1],color[2],
            )
          }
          else{
            let fColor = mixPillarColor(s / (value.shapes.length+1), value.colors)
            let cColor = mixPillarColor((s+1) / (value.shapes.length+1), value.colors)
            if(!iX && !iY){ // !iX && !iY: 4,1,2,3; iY && !iX: 1,2,3,4; iY && iX: 2,3,4,1; !iY && iX: 3,4,1,2
              objects = objects.concat([
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side1 topright-topleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side2 topleft-bottomleft
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT, //side3 bottomleft-bottomright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side4 bottomright-topright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topleft //top
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
              ])
            }
            else if(iY && !iX){
              objects = objects.concat([
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side2 topleft-bottomleft
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT, //side3 bottomleft-bottomright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side4 bottomright-topright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side1 topright-topleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topleft //top
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
              ])
            }
            else if(iY && iX){
              objects = objects.concat([
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT, //side3 bottomleft-bottomright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side4 bottomright-topright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side1 topright-topleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side2 topleft-bottomleft
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,



                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topleft //top
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
              ])
            }
            else if(!iY && iX){
              objects = objects.concat([
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side4 bottomright-topright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side1 topright-topleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+fH)*UNIT, //side2 topleft-bottomleft
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT, //side3 bottomleft-bottomright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT,
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+fH)*UNIT,

                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topleft //top
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
                -FOV*0.5*UNIT+(x+0+stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomleft
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+1-stepD)*UNIT, (z+cH)*UNIT, //bottomright
                -FOV*0.5*UNIT+(x+1-stepD)*UNIT, -FOV*0.5*UNIT+(y+0+stepD)*UNIT, (z+cH)*UNIT, //topright
              ])
            }
            let b = 0.5
            let d = 1 / (1 + b)
            let l1 = 1 + ((0.0 + R) % 1) * b
            let l2 = 1 + ((0.25 + R) % 1) * b
            let l3 = 1 + ((0.5 + R) % 1) * b
            let l4 = 1 + ((0.75 + R) % 1) * b
            let l5 = 1 + b
            objectColors.push(
              fColor[0]*d*l1,fColor[1]*d*l1,fColor[2]*d*l1,
              fColor[0]*d*l1,fColor[1]*d*l1,fColor[2]*d*l1,
              cColor[0]*d*l1,cColor[1]*d*l1,cColor[2]*d*l1,
              cColor[0]*d*l1,cColor[1]*d*l1,cColor[2]*d*l1,
              cColor[0]*d*l1,cColor[1]*d*l1,cColor[2]*d*l1,
              fColor[0]*d*l1,fColor[1]*d*l1,fColor[2]*d*l1,

              fColor[0]*d*l2,fColor[1]*d*l2,fColor[2]*d*l2,
              fColor[0]*d*l2,fColor[1]*d*l2,fColor[2]*d*l2,
              cColor[0]*d*l2,cColor[1]*d*l2,cColor[2]*d*l2,
              cColor[0]*d*l2,cColor[1]*d*l2,cColor[2]*d*l2,
              cColor[0]*d*l2,cColor[1]*d*l2,cColor[2]*d*l2,
              fColor[0]*d*l2,fColor[1]*d*l2,fColor[2]*d*l2,

              fColor[0]*d*l3,fColor[1]*d*l3,fColor[2]*d*l3,
              fColor[0]*d*l3,fColor[1]*d*l3,fColor[2]*d*l3,
              cColor[0]*d*l3,cColor[1]*d*l3,cColor[2]*d*l3,
              cColor[0]*d*l3,cColor[1]*d*l3,cColor[2]*d*l3,
              cColor[0]*d*l3,cColor[1]*d*l3,cColor[2]*d*l3,
              fColor[0]*d*l3,fColor[1]*d*l3,fColor[2]*d*l3,

              fColor[0]*d*l4,fColor[1]*d*l4,fColor[2]*d*l4,
              fColor[0]*d*l4,fColor[1]*d*l4,fColor[2]*d*l4,
              cColor[0]*d*l4,cColor[1]*d*l4,cColor[2]*d*l4,
              cColor[0]*d*l4,cColor[1]*d*l4,cColor[2]*d*l4,
              cColor[0]*d*l4,cColor[1]*d*l4,cColor[2]*d*l4,
              fColor[0]*d*l4,fColor[1]*d*l4,fColor[2]*d*l4,

              fColor[0]*d*l5,fColor[1]*d*l5,fColor[2]*d*l5,
              fColor[0]*d*l5,fColor[1]*d*l5,fColor[2]*d*l5,
              cColor[0]*d*l5,cColor[1]*d*l5,cColor[2]*d*l5,
              cColor[0]*d*l5,cColor[1]*d*l5,cColor[2]*d*l5,
              cColor[0]*d*l5,cColor[1]*d*l5,cColor[2]*d*l5,
              fColor[0]*d*l5,fColor[1]*d*l5,fColor[2]*d*l5,
            )
          }

          objPolygons += 5
        }

      }
    }
    return {
      obj: obj,
      objectColors: objectColors,
      polygonCount: objPolygons
    }
  }
  function setColors(gl,objectColors) {
    let faceColors = new Array(FOV*FOV).fill([
          0,0,0,
          0,0,0,
          0,0,0,
          0,0,0,
          0,0,0,
          0,0,0,
        ]).flat()
      let lineColors = new Array(FOV*FOV).fill([
            200,200,200,
            200,200,200,
            200,200,200,
            200,200,200,
            200,200,200,
            200,200,200,
          ]).flat()
      gl.bufferData(gl.ARRAY_BUFFER,new Uint8Array(lineColors.concat(faceColors).concat(objectColors)),
        gl.STATIC_DRAW);
  }
  function initInfoInterval(){
    INFO_INTERVAL = setInterval(function () {
    if(INFO_FLAG == 0 && !MOVE_INTERVAL && USER_HAS_MOVED_AFTER_CLOSE){
      let pos = {
        x: Math.round((LIMES + ((X + FOV * 0.5) % LIMES)) % LIMES),
        y: Math.round((LIMES + ((Y + FOV * 0.5) % LIMES)) % LIMES)
      }
      for(let _p in PILLARS){
        let p = PILLARS[_p]
        let _x = Math.round((LIMES + (p.x % LIMES)) % LIMES)
        let _y = Math.round((LIMES + (p.y % LIMES)) % LIMES)
        if(pos.x > (_x - INFO_AREA) && pos.x < (_x + INFO_AREA) && pos.y > (_y - INFO_AREA)  && pos.y < (_y + INFO_AREA) ){
          G.openInfo(p)
          return
        }
      }

    }
    else if(INFO_FLAG < 0){
      INFO_FLAG += 1
    }
  }, 250);
  }
}

main()
